#!/usr/bin/env python3
"""
abraxas: Dynamic color temperature daemon with weather awareness

Named for the Gnostic deity of transformation -- the one who bridges light and dark.

Features:
- NOAA sun position calculations (offline)
- Weather-aware temperature adjustments (api.weather.gov)
- Unified sigmoid transitions for solar and manual overrides
- Direct kernel gamma via libmeridian (DRM/X11)
- Flag-based manual mode with auto-resume
- 1-minute update intervals, 15-minute weather refresh
"""

import argparse
import configparser
import ctypes
import json
import math
import mmap
import os
import select
import signal
import struct
import subprocess
import sys
import time
import urllib.request
import urllib.error
from datetime import datetime, timedelta
from pathlib import Path

# === Linux Kernel Interfaces ===

# libc for timerfd and inotify
_libc = ctypes.CDLL('libc.so.6', use_errno=True)

# timerfd constants
CLOCK_MONOTONIC = 1
TFD_CLOEXEC = 0o2000000

# inotify constants
IN_MODIFY = 0x00000002
IN_CLOSE_WRITE = 0x00000008
IN_CLOEXEC = 0o2000000

# signalfd constants
SFD_CLOEXEC = 0o2000000

class timespec(ctypes.Structure):
    _fields_ = [("tv_sec", ctypes.c_long), ("tv_nsec", ctypes.c_long)]

class itimerspec(ctypes.Structure):
    _fields_ = [("it_interval", timespec), ("it_value", timespec)]

# timerfd syscalls
_libc.timerfd_create.argtypes = [ctypes.c_int, ctypes.c_int]
_libc.timerfd_create.restype = ctypes.c_int
_libc.timerfd_settime.argtypes = [ctypes.c_int, ctypes.c_int, ctypes.POINTER(itimerspec), ctypes.POINTER(itimerspec)]
_libc.timerfd_settime.restype = ctypes.c_int

# inotify syscalls
_libc.inotify_init1.argtypes = [ctypes.c_int]
_libc.inotify_init1.restype = ctypes.c_int
_libc.inotify_add_watch.argtypes = [ctypes.c_int, ctypes.c_char_p, ctypes.c_uint32]
_libc.inotify_add_watch.restype = ctypes.c_int

# signalfd syscalls (sigset_t is 128 bytes on Linux x86_64)
_SIGSET_NWORDS = 16  # 1024 bits / 64 bits per word
class sigset_t(ctypes.Structure):
    _fields_ = [("__val", ctypes.c_ulong * _SIGSET_NWORDS)]

_libc.sigemptyset.argtypes = [ctypes.POINTER(sigset_t)]
_libc.sigemptyset.restype = ctypes.c_int
_libc.sigaddset.argtypes = [ctypes.POINTER(sigset_t), ctypes.c_int]
_libc.sigaddset.restype = ctypes.c_int
_libc.sigprocmask.argtypes = [ctypes.c_int, ctypes.POINTER(sigset_t), ctypes.POINTER(sigset_t)]
_libc.sigprocmask.restype = ctypes.c_int
_libc.signalfd.argtypes = [ctypes.c_int, ctypes.POINTER(sigset_t), ctypes.c_int]
_libc.signalfd.restype = ctypes.c_int

# Signal numbers
SIGINT = 2
SIGTERM = 15
SIG_BLOCK = 0


def create_timerfd(interval_sec):
    """Create a timerfd that fires every interval_sec seconds."""
    fd = _libc.timerfd_create(CLOCK_MONOTONIC, TFD_CLOEXEC)
    if fd < 0:
        raise OSError(ctypes.get_errno(), "timerfd_create failed")

    spec = itimerspec()
    spec.it_interval.tv_sec = interval_sec
    spec.it_interval.tv_nsec = 0
    spec.it_value.tv_sec = interval_sec
    spec.it_value.tv_nsec = 0

    if _libc.timerfd_settime(fd, 0, ctypes.byref(spec), None) < 0:
        os.close(fd)
        raise OSError(ctypes.get_errno(), "timerfd_settime failed")

    return fd


def create_inotify_watch(path):
    """Create inotify watch for config file changes."""
    fd = _libc.inotify_init1(IN_CLOEXEC)
    if fd < 0:
        raise OSError(ctypes.get_errno(), "inotify_init1 failed")

    watch_path = str(path.parent).encode('utf-8')
    wd = _libc.inotify_add_watch(fd, watch_path, IN_CLOSE_WRITE | IN_MODIFY)
    if wd < 0:
        os.close(fd)
        raise OSError(ctypes.get_errno(), "inotify_add_watch failed")

    return fd, path.name


def create_signalfd():
    """Create signalfd for SIGTERM and SIGINT (clean shutdown via select)."""
    mask = sigset_t()
    _libc.sigemptyset(ctypes.byref(mask))
    _libc.sigaddset(ctypes.byref(mask), SIGINT)
    _libc.sigaddset(ctypes.byref(mask), SIGTERM)

    if _libc.sigprocmask(SIG_BLOCK, ctypes.byref(mask), None) < 0:
        raise OSError(ctypes.get_errno(), "sigprocmask failed")

    fd = _libc.signalfd(-1, ctypes.byref(mask), SFD_CLOEXEC)
    if fd < 0:
        raise OSError(ctypes.get_errno(), "signalfd failed")

    return fd

# === Configuration ===

CONFIG_DIR = Path.home() / ".config" / "abraxas"
CONFIG_FILE = CONFIG_DIR / "config.ini"
CACHE_FILE = CONFIG_DIR / "weather_cache.json"
OVERRIDE_FILE = CONFIG_DIR / "override.json"
ZIPDB_FILE = CONFIG_DIR / "us_zipcodes.bin"

# Temperature bounds (match libmeridian)
TEMP_MIN = 1000
TEMP_MAX = 25000

# Temperature settings (Kelvin)
TEMP_DAY_CLEAR = 6500
TEMP_DAY_DARK = 4500
TEMP_NIGHT = 2900

# Thresholds
CLOUD_THRESHOLD = 75  # % cloud cover to trigger dark mode

# Timing
WEATHER_REFRESH_MINUTES = 15
TEMP_UPDATE_SECONDS = 60

# Transition windows (minutes)
DAWN_DURATION = 90
DUSK_DURATION = 120



# === NOAA Sun Position Calculations ===

def julian_day(dt):
    """Calculate Julian Day from datetime."""
    year, month, day = dt.year, dt.month, dt.day
    hour = dt.hour + dt.minute / 60 + dt.second / 3600

    if month <= 2:
        year -= 1
        month += 12

    A = int(year / 100)
    B = 2 - A + int(A / 4)

    jd = int(365.25 * (year + 4716)) + int(30.6001 * (month + 1)) + day + B - 1524.5
    jd += hour / 24.0

    return jd

def get_tz_offset_hours():
    """Get timezone offset in hours from kernel via localtime."""
    return time.localtime().tm_gmtoff / 3600

def sun_position(dt, lat, lon):
    """
    Calculate sun position using NOAA solar equations.
    Returns solar elevation angle in degrees.
    """
    jd = julian_day(dt)
    jc = (jd - 2451545) / 36525  # Julian century

    # Geometric mean longitude of sun (degrees)
    L0 = (280.46646 + jc * (36000.76983 + 0.0003032 * jc)) % 360

    # Geometric mean anomaly of sun (degrees)
    M = 357.52911 + jc * (35999.05029 - 0.0001537 * jc)
    M_rad = math.radians(M)

    # Eccentricity of Earth's orbit
    e = 0.016708634 - jc * (0.000042037 + 0.0000001267 * jc)

    # Sun's equation of center
    C = (math.sin(M_rad) * (1.914602 - jc * (0.004817 + 0.000014 * jc)) +
         math.sin(2 * M_rad) * (0.019993 - 0.000101 * jc) +
         math.sin(3 * M_rad) * 0.000289)

    # Sun's true longitude
    sun_lon = L0 + C

    # Sun's apparent longitude
    omega = 125.04 - 1934.136 * jc
    sun_apparent_lon = sun_lon - 0.00569 - 0.00478 * math.sin(math.radians(omega))

    # Mean obliquity of ecliptic
    obliq_mean = 23 + (26 + (21.448 - jc * (46.815 + jc * (0.00059 - jc * 0.001813))) / 60) / 60

    # Corrected obliquity
    obliq_corr = obliq_mean + 0.00256 * math.cos(math.radians(omega))
    obliq_corr_rad = math.radians(obliq_corr)

    # Sun's declination
    sun_declin = math.degrees(math.asin(math.sin(obliq_corr_rad) *
                                         math.sin(math.radians(sun_apparent_lon))))

    # Equation of time (minutes)
    var_y = math.tan(obliq_corr_rad / 2) ** 2
    eq_time = 4 * math.degrees(
        var_y * math.sin(2 * math.radians(L0)) -
        2 * e * math.sin(M_rad) +
        4 * e * var_y * math.sin(M_rad) * math.cos(2 * math.radians(L0)) -
        0.5 * var_y ** 2 * math.sin(4 * math.radians(L0)) -
        1.25 * e ** 2 * math.sin(2 * M_rad)
    )

    # True solar time
    time_offset = eq_time + 4 * lon - 60 * (get_tz_offset_hours())
    tst = dt.hour * 60 + dt.minute + dt.second / 60 + time_offset

    # Hour angle
    hour_angle = tst / 4 - 180
    if hour_angle < -180:
        hour_angle += 360

    # Solar zenith and elevation
    lat_rad = math.radians(lat)
    declin_rad = math.radians(sun_declin)
    hour_angle_rad = math.radians(hour_angle)

    zenith = math.degrees(math.acos(
        math.sin(lat_rad) * math.sin(declin_rad) +
        math.cos(lat_rad) * math.cos(declin_rad) * math.cos(hour_angle_rad)
    ))

    elevation = 90 - zenith

    return elevation

def calculate_sunrise_sunset(dt, lat, lon):
    """
    Calculate sunrise and sunset times for a given date and location.
    Returns (sunrise, sunset) as datetime objects.
    """
    jd = julian_day(datetime(dt.year, dt.month, dt.day, 12, 0, 0))
    jc = (jd - 2451545) / 36525

    L0 = (280.46646 + jc * (36000.76983 + 0.0003032 * jc)) % 360
    M = 357.52911 + jc * (35999.05029 - 0.0001537 * jc)
    M_rad = math.radians(M)

    e = 0.016708634 - jc * (0.000042037 + 0.0000001267 * jc)

    C = (math.sin(M_rad) * (1.914602 - jc * (0.004817 + 0.000014 * jc)) +
         math.sin(2 * M_rad) * (0.019993 - 0.000101 * jc) +
         math.sin(3 * M_rad) * 0.000289)

    sun_lon = L0 + C

    omega = 125.04 - 1934.136 * jc
    obliq_mean = 23 + (26 + (21.448 - jc * (46.815 + jc * (0.00059 - jc * 0.001813))) / 60) / 60
    obliq_corr = obliq_mean + 0.00256 * math.cos(math.radians(omega))

    sun_apparent_lon = sun_lon - 0.00569 - 0.00478 * math.sin(math.radians(omega))
    sun_declin = math.degrees(math.asin(math.sin(math.radians(obliq_corr)) *
                                         math.sin(math.radians(sun_apparent_lon))))

    var_y = math.tan(math.radians(obliq_corr) / 2) ** 2
    eq_time = 4 * math.degrees(
        var_y * math.sin(2 * math.radians(L0)) -
        2 * e * math.sin(M_rad) +
        4 * e * var_y * math.sin(M_rad) * math.cos(2 * math.radians(L0)) -
        0.5 * var_y ** 2 * math.sin(4 * math.radians(L0)) -
        1.25 * e ** 2 * math.sin(2 * M_rad)
    )

    zenith = 90.833
    lat_rad = math.radians(lat)
    declin_rad = math.radians(sun_declin)

    cos_ha = (math.cos(math.radians(zenith)) / (math.cos(lat_rad) * math.cos(declin_rad)) -
              math.tan(lat_rad) * math.tan(declin_rad))

    cos_ha = max(-1, min(1, cos_ha))
    ha = math.degrees(math.acos(cos_ha))

    tz_offset = get_tz_offset_hours()

    sunrise_min = 720 - 4 * (lon + ha) - eq_time + tz_offset * 60
    sunset_min = 720 - 4 * (lon - ha) - eq_time + tz_offset * 60

    base_date = datetime(dt.year, dt.month, dt.day)
    sunrise = base_date + timedelta(minutes=sunrise_min)
    sunset = base_date + timedelta(minutes=sunset_min)

    return sunrise, sunset

# === Weather API ===

def get_grid_point(lat, lon):
    """Get NWS grid point for coordinates."""
    url = f"https://api.weather.gov/points/{lat},{lon}"
    headers = {"User-Agent": "abraxas/1.0 (weather color temp daemon)"}

    req = urllib.request.Request(url, headers=headers)
    with urllib.request.urlopen(req, timeout=10) as response:
        data = json.loads(response.read().decode())
        return data["properties"]["forecastHourly"]

def fetch_weather(lat, lon):
    """
    Fetch current weather from NOAA api.weather.gov.
    Returns dict with cloud_cover, conditions, etc.
    """
    try:
        forecast_url = get_grid_point(lat, lon)
        headers = {"User-Agent": "abraxas/1.0 (weather color temp daemon)"}

        req = urllib.request.Request(forecast_url, headers=headers)
        with urllib.request.urlopen(req, timeout=10) as response:
            data = json.loads(response.read().decode())

        period = data["properties"]["periods"][0]

        cloud_cover = period.get("probabilityOfPrecipitation", {}).get("value", 0) or 0

        forecast = period.get("shortForecast", "").lower()

        if any(word in forecast for word in ["sunny", "clear"]):
            cloud_cover = 10
        elif "mostly sunny" in forecast or "mostly clear" in forecast:
            cloud_cover = 25
        elif "partly" in forecast:
            cloud_cover = 50
        elif "mostly cloudy" in forecast:
            cloud_cover = 75
        elif any(word in forecast for word in ["cloudy", "overcast"]):
            cloud_cover = 90
        elif any(word in forecast for word in ["rain", "storm", "snow", "drizzle", "showers"]):
            cloud_cover = 95

        return {
            "cloud_cover": cloud_cover,
            "forecast": period.get("shortForecast", "Unknown"),
            "temperature": period.get("temperature"),
            "is_day": period.get("isDaytime", True),
            "fetched_at": datetime.now().isoformat()
        }

    except Exception as e:
        return {"error": str(e), "cloud_cover": 0, "fetched_at": datetime.now().isoformat()}

def load_weather_cache():
    """Load cached weather data."""
    if CACHE_FILE.exists():
        try:
            with open(CACHE_FILE) as f:
                return json.load(f)
        except:
            pass
    return None

def save_weather_cache(data):
    """Save weather data to cache."""
    with open(CACHE_FILE, "w") as f:
        json.dump(data, f, indent=2)

def should_refresh_weather(cache):
    """Check if weather cache needs refresh."""
    if not cache or "fetched_at" not in cache:
        return True

    try:
        fetched = datetime.fromisoformat(cache["fetched_at"])
        age = datetime.now() - fetched
        return age.total_seconds() > WEATHER_REFRESH_MINUTES * 60
    except:
        return True

# === Override State ===

def load_override():
    """Load manual override state. Returns dict or None."""
    if OVERRIDE_FILE.exists():
        try:
            with open(OVERRIDE_FILE) as f:
                return json.load(f)
        except:
            pass
    return None

def save_override(data):
    """Write override state to file."""
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    with open(OVERRIDE_FILE, "w") as f:
        json.dump(data, f, indent=2)

def clear_override():
    """Remove override file."""
    try:
        OVERRIDE_FILE.unlink()
    except FileNotFoundError:
        pass

# === Sigmoid Transition ===

def sigmoid(x, steepness=6):
    """
    Compute sigmoid function.
    x should be in range [-1, 1] for typical use.
    Returns value in range [0, 1].
    """
    return 1 / (1 + math.exp(-steepness * x))

def sigmoid_norm(x, steepness=6):
    """Sigmoid normalized to exactly [0, 1] over [-1, 1]."""
    raw = sigmoid(x, steepness)
    low = sigmoid(-1, steepness)
    high = sigmoid(1, steepness)
    return (raw - low) / (high - low)

def calculate_temperature(sun_elevation, minutes_to_sunset, minutes_from_sunrise,
                          is_dark_mode, sunrise, sunset):
    """
    Calculate target color temperature using sigmoid transitions.

    Dusk is the canonical transition (day -> night). Dawn is its inverse
    (night -> day). Both use the full sigmoid over [-1, 1], centered on
    the event time with windows of DAWN_DURATION and DUSK_DURATION.
    """
    day_temp = TEMP_DAY_DARK if is_dark_mode else TEMP_DAY_CLEAR
    night_temp = TEMP_NIGHT

    dawn_half = DAWN_DURATION / 2
    dusk_half = DUSK_DURATION / 2

    # Dawn: night -> day (inverse of dusk)
    if abs(minutes_from_sunrise) < dawn_half:
        x = minutes_from_sunrise / dawn_half          # [-1, 1] = night to day
        factor = sigmoid_norm(x)                       # [0, 1]
        return int(night_temp + (day_temp - night_temp) * factor)

    # Dusk: day -> night (canonical)
    if abs(minutes_to_sunset) < dusk_half:
        x = minutes_to_sunset / dusk_half              # [1, -1] = day to night
        factor = sigmoid_norm(x)                       # [1, 0]
        return int(night_temp + (day_temp - night_temp) * factor)

    # Daytime (between windows)
    if minutes_from_sunrise >= dawn_half and minutes_to_sunset >= dusk_half:
        return day_temp

    # Night (before dawn or after dusk)
    return night_temp

def solar_temperature(now, lat, lon, weather_cache):
    """Calculate current solar-based temperature (convenience wrapper)."""
    sunrise, sunset = calculate_sunrise_sunset(now, lat, lon)
    elevation = sun_position(now, lat, lon)
    minutes_to_sunset = (sunset - now).total_seconds() / 60
    minutes_from_sunrise = (now - sunrise).total_seconds() / 60
    cloud_cover = weather_cache.get("cloud_cover", 0) if weather_cache else 0
    is_dark = cloud_cover >= CLOUD_THRESHOLD
    return calculate_temperature(elevation, minutes_to_sunset, minutes_from_sunrise,
                                  is_dark, sunrise, sunset)

def manual_temperature(start_temp, target_temp, start_time, duration_min, now):
    """
    Calculate manual override temperature using sigmoid transition.

    Same sigmoid function as solar transitions. Maps elapsed time into [-1, 1]
    over the duration window, interpolates between start and target temps.
    """
    if duration_min <= 0:
        return target_temp

    elapsed_min = (now - start_time).total_seconds() / 60

    if elapsed_min >= duration_min:
        return target_temp

    # Map [0, duration] -> [-1, 1]
    x = 2 * (elapsed_min / duration_min) - 1
    factor = sigmoid_norm(x)
    return int(start_temp + (target_temp - start_temp) * factor)

def next_transition_resume_time(now, lat, lon):
    """
    Calculate when manual override should auto-resume solar control.
    Returns datetime 15 minutes before the next dawn/dusk transition window.
    """
    sunrise, sunset = calculate_sunrise_sunset(now, lat, lon)

    dawn_window_start = sunrise - timedelta(minutes=DAWN_DURATION / 2)
    dusk_window_start = sunset - timedelta(minutes=DUSK_DURATION / 2)

    resume_before_dawn = dawn_window_start - timedelta(minutes=15)
    resume_before_dusk = dusk_window_start - timedelta(minutes=15)

    candidates = []
    if resume_before_dawn > now:
        candidates.append(resume_before_dawn)
    if resume_before_dusk > now:
        candidates.append(resume_before_dusk)

    if candidates:
        return min(candidates)

    # Both today's transitions passed -- use tomorrow's dawn
    tomorrow = now + timedelta(days=1)
    sunrise_t, _ = calculate_sunrise_sunset(tomorrow, lat, lon)
    return sunrise_t - timedelta(minutes=DAWN_DURATION / 2 + 15)

# === libmeridian Gamma Control ===

_libmeridian = None
_meridian_state = None

def _init_libmeridian():
    """Initialize libmeridian library."""
    global _libmeridian, _meridian_state

    if _libmeridian is not None:
        return _meridian_state is not None

    lib_paths = [
        "/usr/local/lib/libmeridian.so",
        str(Path.home() / ".local/lib/libmeridian.so"),
        str(CONFIG_DIR / "libmeridian.so"),
    ]

    for path in lib_paths:
        try:
            _libmeridian = ctypes.CDLL(path, use_errno=True)
            break
        except OSError:
            continue

    if _libmeridian is None:
        print("[libmeridian] Library not found, falling back to redshift binary", file=sys.stderr)
        return False

    _libmeridian.meridian_init.argtypes = [ctypes.POINTER(ctypes.c_void_p)]
    _libmeridian.meridian_init.restype = ctypes.c_int

    _libmeridian.meridian_free.argtypes = [ctypes.c_void_p]
    _libmeridian.meridian_free.restype = None

    _libmeridian.meridian_set_temperature.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_float]
    _libmeridian.meridian_set_temperature.restype = ctypes.c_int

    _libmeridian.meridian_restore.argtypes = [ctypes.c_void_p]
    _libmeridian.meridian_restore.restype = ctypes.c_int

    _libmeridian.meridian_get_backend_name.argtypes = [ctypes.c_void_p]
    _libmeridian.meridian_get_backend_name.restype = ctypes.c_char_p

    _libmeridian.meridian_strerror.argtypes = [ctypes.c_int]
    _libmeridian.meridian_strerror.restype = ctypes.c_char_p

    state_ptr = ctypes.c_void_p()
    err = _libmeridian.meridian_init(ctypes.byref(state_ptr))

    if err != 0:
        err_msg = _libmeridian.meridian_strerror(err).decode('utf-8')
        print(f"[libmeridian] Init failed: {err_msg}", file=sys.stderr)
        _libmeridian = None
        return False

    _meridian_state = state_ptr
    backend = _libmeridian.meridian_get_backend_name(state_ptr).decode('utf-8')
    print(f"[libmeridian] Initialized with {backend} backend")
    return True


def set_temperature(temp):
    """Set screen color temperature via libmeridian (or redshift fallback)."""
    global _libmeridian, _meridian_state

    if _init_libmeridian() and _meridian_state:
        err = _libmeridian.meridian_set_temperature(_meridian_state, temp, ctypes.c_float(1.0))
        if err == 0:
            return True
        err_msg = _libmeridian.meridian_strerror(err).decode('utf-8')
        print(f"[libmeridian] Set temperature failed: {err_msg}", file=sys.stderr)

    try:
        subprocess.run(
            ["redshift", "-P", "-O", f"{temp}K"],
            check=True,
            capture_output=True
        )
        return True
    except (subprocess.CalledProcessError, FileNotFoundError) as e:
        print(f"Error setting temperature: {e}", file=sys.stderr)
        return False


def reset_temperature():
    """Reset screen to default color temperature."""
    global _libmeridian, _meridian_state

    if _meridian_state and _libmeridian:
        _libmeridian.meridian_restore(_meridian_state)
        return

    try:
        subprocess.run(["redshift", "-x"], check=True, capture_output=True)
    except:
        pass


def cleanup_libmeridian():
    """Clean up libmeridian state on exit."""
    global _libmeridian, _meridian_state
    if _meridian_state and _libmeridian:
        _libmeridian.meridian_free(_meridian_state)
        _meridian_state = None

# === Configuration ===

def load_config():
    """Load configuration from file."""
    config = configparser.ConfigParser()

    if CONFIG_FILE.exists():
        config.read(CONFIG_FILE)

    return {
        "latitude": config.getfloat("location", "latitude", fallback=None),
        "longitude": config.getfloat("location", "longitude", fallback=None),
    }

def save_config(lat, lon):
    """Save configuration to file."""
    config = configparser.ConfigParser()
    config["location"] = {
        "latitude": str(lat),
        "longitude": str(lon)
    }

    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    with open(CONFIG_FILE, "w") as f:
        config.write(f)

def zip_to_coordinates(zipcode):
    """Convert ZIP code to coordinates using mmap'd binary database."""
    if not ZIPDB_FILE.exists():
        print(f"ZIP database not found: {ZIPDB_FILE}", file=sys.stderr)
        print("Please install us_zipcodes.bin to your config directory.", file=sys.stderr)
        return None, None

    zipcode = zipcode.zfill(5)[:5].encode('ascii')

    try:
        with open(ZIPDB_FILE, 'rb') as f:
            mm = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)

            try:
                count = struct.unpack('<I', mm[0:4])[0]

                entry_size = 13
                low, high = 0, count - 1

                while low <= high:
                    mid = (low + high) // 2
                    offset = 4 + mid * entry_size

                    entry_zip = mm[offset:offset + 5]

                    if entry_zip == zipcode:
                        lat, lon = struct.unpack('<ff', mm[offset + 5:offset + 13])
                        print(f"Found: {zipcode.decode()} -> {lat:.4f}, {lon:.4f}")
                        return lat, lon
                    elif entry_zip < zipcode:
                        low = mid + 1
                    else:
                        high = mid - 1

                print(f"ZIP code {zipcode.decode()} not found in database.", file=sys.stderr)
                return None, None

            finally:
                mm.close()

    except Exception as e:
        print(f"Error reading ZIP database: {e}", file=sys.stderr)
        return None, None

# === CLI Interface ===

def cmd_status(lat, lon):
    """Show current status."""
    print(f"Location: {lat}, {lon}")
    print()

    now = datetime.now()
    sunrise, sunset = calculate_sunrise_sunset(now, lat, lon)
    elevation = sun_position(now, lat, lon)

    print(f"Date: {now.strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"Sunrise: {sunrise.strftime('%H:%M')}")
    print(f"Sunset: {sunset.strftime('%H:%M')}")
    print(f"Sun elevation: {elevation:.1f} degrees")
    print()

    weather = load_weather_cache()
    if weather and "error" not in weather:
        print(f"Weather: {weather.get('forecast', 'Unknown')}")
        print(f"Cloud cover: {weather.get('cloud_cover', 'Unknown')}%")
        print(f"Last updated: {weather.get('fetched_at', 'Unknown')}")
    else:
        print("Weather: Not available (run daemon to fetch)")
    print()

    # Check manual override
    override = load_override()
    if override and override.get("active"):
        target = override.get("target_temp", "?")
        duration = override.get("duration_minutes", 0)
        issued = override.get("issued_at", "?")
        print(f"Mode: MANUAL OVERRIDE")
        print(f"Target: {target}K over {duration} min")
        print(f"Issued: {issued}")
    else:
        is_dark = weather.get("cloud_cover", 0) >= CLOUD_THRESHOLD if weather else False
        minutes_to_sunset = (sunset - now).total_seconds() / 60
        minutes_from_sunrise = (now - sunrise).total_seconds() / 60

        temp = calculate_temperature(elevation, minutes_to_sunset, minutes_from_sunrise,
                                      is_dark, sunrise, sunset)

        mode = "DARK" if is_dark else "CLEAR"
        print(f"Mode: {mode}")
        print(f"Target temperature: {temp}K")

def cmd_set_location(location_str):
    """Set location from ZIP or lat,lon."""
    if "," in location_str:
        try:
            lat, lon = map(float, location_str.split(","))
            save_config(lat, lon)
            print(f"Location set to: {lat}, {lon}")
            return True
        except ValueError:
            print("Invalid format. Use: LAT,LON (e.g., 41.88,-87.63)", file=sys.stderr)
            return False
    else:
        zipcode = location_str.strip()
        if not zipcode.isdigit() or len(zipcode) != 5:
            print("Invalid ZIP code. Must be 5 digits.", file=sys.stderr)
            return False

        print(f"Looking up ZIP code {zipcode}...")
        lat, lon = zip_to_coordinates(zipcode)

        if lat and lon:
            save_config(lat, lon)
            print(f"Location set to: {lat}, {lon}")
            return True
        else:
            print("Could not find coordinates for ZIP code.", file=sys.stderr)
            return False

def cmd_refresh():
    """Force weather refresh."""
    config = load_config()
    if not config["latitude"] or not config["longitude"]:
        print("No location set. Use --set-location first.", file=sys.stderr)
        return False

    print("Fetching weather...")
    weather = fetch_weather(config["latitude"], config["longitude"])

    if "error" in weather:
        print(f"Error: {weather['error']}", file=sys.stderr)
        return False

    save_weather_cache(weather)
    print(f"Weather: {weather.get('forecast', 'Unknown')}")
    print(f"Cloud cover: {weather.get('cloud_cover', 'Unknown')}%")
    return True

def cmd_set_temp(target_temp, duration_min):
    """
    Signal the running daemon to transition to target temperature.

    Writes a control payload to override.json. The daemon detects the change
    via inotify and drives the sigmoid transition itself.
    """
    if target_temp < TEMP_MIN or target_temp > TEMP_MAX:
        print(f"Temperature must be between {TEMP_MIN}K and {TEMP_MAX}K.", file=sys.stderr)
        return False

    override = {
        "active": True,
        "target_temp": target_temp,
        "duration_minutes": duration_min,
        "issued_at": datetime.now().isoformat()
    }
    save_override(override)

    if duration_min > 0:
        print(f"Override: -> {target_temp}K over {duration_min} min (sigmoid)")
    else:
        print(f"Override: -> {target_temp}K (instant)")
    print("Daemon will process on next tick (up to 60s).")
    return True

def cmd_resume():
    """Signal daemon to clear manual override and resume solar control."""
    save_override({"active": False})
    print("Resume sent. Daemon will return to solar control.")

# === Daemon ===

def daemon_loop(lat, lon):
    """
    Main daemon loop using Linux kernel timerfd, inotify, and signalfd.

    Handles both solar-based and manual override transitions using the same
    sigmoid function. Manual overrides are flag-based: when active, the daemon
    stops evaluating solar/weather and drives the manual transition instead.
    After the manual transition completes, the daemon holds at the target
    temperature until 15 minutes before the next natural transition window,
    then auto-resumes solar control.
    """
    print(f"Starting abraxas daemon")
    print(f"Location: {lat}, {lon}")
    print(f"Weather refresh: every {WEATHER_REFRESH_MINUTES} min")
    print(f"Temperature update: every {TEMP_UPDATE_SECONDS}s")
    print(f"Using kernel timerfd + inotify + signalfd")
    print()

    last_temp = None
    weather_cache = load_weather_cache()
    config_changed = False
    override_changed = False
    running = True

    # Manual override state
    manual_mode = False
    manual_start_temp = None
    manual_target_temp = None
    manual_start_time = None
    manual_duration_min = None
    manual_issued_at = None
    manual_resume_time = None

    # Create timerfd for precise 60-second intervals
    timer_fd = None
    try:
        timer_fd = create_timerfd(TEMP_UPDATE_SECONDS)
        print(f"[kernel] timerfd created (fd={timer_fd})")
    except OSError as e:
        print(f"[warn] timerfd failed ({e}), falling back to time.sleep()", file=sys.stderr)

    # Create inotify watch for config changes
    inotify_fd = None
    config_filename = None
    try:
        inotify_fd, config_filename = create_inotify_watch(CONFIG_FILE)
        print(f"[kernel] inotify watching {CONFIG_FILE.parent} (fd={inotify_fd})")
    except OSError as e:
        print(f"[warn] inotify failed ({e}), config changes require restart", file=sys.stderr)

    # Create signalfd for clean shutdown (SIGTERM, SIGINT)
    signal_fd = None
    try:
        signal_fd = create_signalfd()
        print(f"[kernel] signalfd created (fd={signal_fd})")
    except OSError as e:
        print(f"[warn] signalfd failed ({e}), using fallback signal handlers", file=sys.stderr)
        def handle_signal(signum, frame):
            nonlocal running
            running = False
        signal.signal(signal.SIGTERM, handle_signal)
        signal.signal(signal.SIGINT, handle_signal)

    # Build poll list
    poll_fds = []
    if timer_fd is not None:
        poll_fds.append(timer_fd)
    if inotify_fd is not None:
        poll_fds.append(inotify_fd)
    if signal_fd is not None:
        poll_fds.append(signal_fd)

    # Recover from active override on restart
    override_data = load_override()
    if override_data and override_data.get("active"):
        manual_mode = True
        manual_target_temp = override_data["target_temp"]
        manual_duration_min = override_data.get("duration_minutes", 3)
        manual_issued_at = override_data.get("issued_at", "")
        manual_start_time = datetime.fromisoformat(manual_issued_at)
        manual_start_temp = override_data.get("start_temp")
        if manual_start_temp is None:
            manual_start_temp = solar_temperature(datetime.now(), lat, lon, weather_cache)
            override_data["start_temp"] = manual_start_temp
            save_override(override_data)
        manual_resume_time = next_transition_resume_time(datetime.now(), lat, lon)
        print(f"[manual] Recovered override: -> {manual_target_temp}K ({manual_duration_min} min)")
        print(f"[manual] Auto-resume at: {manual_resume_time.strftime('%H:%M')}")

    try:
        while running:
            try:
                # Wait for timer, inotify, or signal event
                if poll_fds:
                    timeout = TEMP_UPDATE_SECONDS if timer_fd is None else None
                    readable, _, _ = select.select(poll_fds, [], [], timeout)

                    for fd in readable:
                        if fd == timer_fd:
                            os.read(timer_fd, 8)
                        elif fd == signal_fd:
                            os.read(signal_fd, 128)
                            print("\nReceived shutdown signal...")
                            running = False
                            break
                        elif fd == inotify_fd:
                            data = os.read(inotify_fd, 4096)
                            offset = 0
                            while offset < len(data):
                                wd, mask, cookie, length = struct.unpack_from('iIII', data, offset)
                                name = data[offset + 16:offset + 16 + length].rstrip(b'\x00').decode('utf-8', errors='ignore')
                                if name == OVERRIDE_FILE.name:
                                    override_changed = True
                                if name == config_filename or name == CACHE_FILE.name:
                                    config_changed = True
                                    print(f"[inotify] {name} changed, reloading...")
                                offset += 16 + length
                else:
                    time.sleep(TEMP_UPDATE_SECONDS)

                if not running:
                    break

                now = datetime.now()

                # Reload config if changed
                if config_changed:
                    new_config = load_config()
                    if new_config["latitude"] and new_config["longitude"]:
                        lat, lon = new_config["latitude"], new_config["longitude"]
                        print(f"[config] Location updated: {lat}, {lon}")
                    weather_cache = load_weather_cache()
                    config_changed = False

                # Process override changes
                if override_changed:
                    od = load_override()
                    if od and od.get("active"):
                        new_issued = od.get("issued_at", "")
                        if new_issued != manual_issued_at:
                            # New override command from CLI
                            manual_mode = True
                            manual_issued_at = new_issued
                            manual_target_temp = od["target_temp"]
                            manual_duration_min = od.get("duration_minutes", 3)
                            manual_start_time = datetime.fromisoformat(new_issued)
                            manual_start_temp = last_temp or solar_temperature(now, lat, lon, weather_cache)

                            # Persist start_temp for restart recovery
                            if "start_temp" not in od:
                                od["start_temp"] = manual_start_temp
                                save_override(od)

                            manual_resume_time = next_transition_resume_time(now, lat, lon)

                            if manual_duration_min > 0:
                                print(f"[manual] Override: {manual_start_temp}K -> {manual_target_temp}K over {manual_duration_min} min")
                            else:
                                print(f"[manual] Override: -> {manual_target_temp}K (instant)")
                            print(f"[manual] Auto-resume at: {manual_resume_time.strftime('%H:%M')}")

                    elif od is not None and not od.get("active"):
                        # Resume command from CLI
                        if manual_mode:
                            manual_mode = False
                            manual_issued_at = None
                            clear_override()
                            print("[manual] Override cleared, resuming solar control")

                    override_changed = False

                # Refresh weather if needed
                if should_refresh_weather(weather_cache):
                    print(f"[{now.strftime('%H:%M:%S')}] Refreshing weather...")
                    weather_cache = fetch_weather(lat, lon)
                    save_weather_cache(weather_cache)
                    if "error" not in weather_cache:
                        print(f"  Weather: {weather_cache.get('forecast')} ({weather_cache.get('cloud_cover')}% clouds)")
                    else:
                        print(f"  Weather fetch failed: {weather_cache.get('error')}")

                # Calculate temperature
                if manual_mode:
                    temp = manual_temperature(manual_start_temp, manual_target_temp,
                                              manual_start_time, manual_duration_min, now)

                    # Check auto-resume (only after transition is complete)
                    elapsed = (now - manual_start_time).total_seconds() / 60
                    if elapsed >= manual_duration_min and manual_resume_time and now >= manual_resume_time:
                        manual_mode = False
                        manual_issued_at = None
                        clear_override()
                        print(f"[manual] Auto-resuming solar control (transition window approaching)")
                        temp = solar_temperature(now, lat, lon, weather_cache)
                else:
                    temp = solar_temperature(now, lat, lon, weather_cache)

                # Apply temperature if changed
                if temp != last_temp:
                    if manual_mode:
                        elapsed = (now - manual_start_time).total_seconds() / 60
                        if elapsed < manual_duration_min:
                            pct = min(100, int(elapsed / manual_duration_min * 100))
                            print(f"[{now.strftime('%H:%M:%S')}] Manual: {temp}K ({pct}%)")
                        else:
                            print(f"[{now.strftime('%H:%M:%S')}] Manual: {temp}K (holding)")
                    else:
                        elevation = sun_position(now, lat, lon)
                        cloud_cover = weather_cache.get("cloud_cover", 0) if weather_cache else 0
                        print(f"[{now.strftime('%H:%M:%S')}] Solar: {temp}K (sun: {elevation:.1f}, clouds: {cloud_cover}%)")
                    set_temperature(temp)
                    last_temp = temp

            except KeyboardInterrupt:
                running = False
            except Exception as e:
                print(f"Error in daemon loop: {e}", file=sys.stderr)
                time.sleep(TEMP_UPDATE_SECONDS)

    finally:
        print("Shutting down...")
        if timer_fd is not None:
            os.close(timer_fd)
        if inotify_fd is not None:
            os.close(inotify_fd)
        if signal_fd is not None:
            os.close(signal_fd)

def main():
    parser = argparse.ArgumentParser(
        description="ABRAXAS - Dynamic color temperature daemon with weather awareness"
    )
    parser.add_argument("--status", action="store_true",
                        help="Show current status and calculated temperature")
    parser.add_argument("--set-location", metavar="LOC",
                        help="Set location (ZIP code or LAT,LON)")
    parser.add_argument("--refresh", action="store_true",
                        help="Force weather refresh")
    parser.add_argument("--daemon", action="store_true",
                        help="Run as daemon (default if no other args)")
    parser.add_argument("--reset", action="store_true",
                        help="Reset screen to default temperature and exit")
    parser.add_argument("--set", nargs='+', metavar=("TEMP", "MINUTES"),
                        help="Transition to TEMP (Kelvin) over MINUTES (default 3)")
    parser.add_argument("--resume", action="store_true",
                        help="Clear manual override and resume solar-based control")

    args = parser.parse_args()

    # Handle reset
    if args.reset:
        clear_override()
        reset_temperature()
        print("Screen temperature reset.")
        return 0

    # Handle resume
    if args.resume:
        cmd_resume()
        return 0

    # Handle set-location
    if args.set_location:
        return 0 if cmd_set_location(args.set_location) else 1

    # Load config for remaining commands
    config = load_config()

    if not config["latitude"] or not config["longitude"]:
        print("No location configured. Use --set-location first.", file=sys.stderr)
        print("  Example: abraxas --set-location 60614", file=sys.stderr)
        print("  Example: abraxas --set-location 41.88,-87.63", file=sys.stderr)
        return 1

    lat, lon = config["latitude"], config["longitude"]

    # Handle status
    if args.status:
        cmd_status(lat, lon)
        return 0

    # Handle refresh
    if args.refresh:
        return 0 if cmd_refresh() else 1

    # Handle set temperature
    if args.set:
        try:
            target_temp = int(args.set[0])
            duration = int(args.set[1]) if len(args.set) > 1 else 3
        except ValueError:
            print("Usage: abraxas --set TEMP [MINUTES]", file=sys.stderr)
            print("  Example: abraxas --set 2900 30", file=sys.stderr)
            return 1
        return 0 if cmd_set_temp(target_temp, duration) else 1

    # Default: run daemon
    try:
        daemon_loop(lat, lon)
    finally:
        reset_temperature()
        cleanup_libmeridian()
    return 0

if __name__ == "__main__":
    sys.exit(main())
